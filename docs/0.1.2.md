Perfect refinement ‚Äî named child registration is a clean and powerful enhancement. Here's the updated implementation note with that refinement:

---

## üìù `fossa-fsm`: Enforced Single Root + Named Child FSMs + Lifecycle Hooks

### üéØ Goals Recap

* `fossa()` creates the **one and only root FSM**
* `fossa.child(name, def)` registers **named child FSMs**
* `fossa.send(event)` dispatches to **root**
* `fossa.send(name, event)` dispatches to **named child FSM**
* Support for **lifecycle hooks** across all FSMs

---

## ‚úÖ Updated API

```ts
const root = fossa({...});                   // must be called once
const game = fossa.child('game', {...});     // child FSM registered as 'game'
const settings = fossa.child('settings', {...});

fossa.send({ type: 'start_game' });                 // sends to root
fossa.send('game', { type: 'clicked_card', card }); // sends to 'game' FSM
```

---

## üîê Internal Enforcement

### 1. FSM Registry

```ts
let rootFSMInstance: FSMInstance<any, any> | null = null;
const childRegistry: Record<string, FSMInstance<any, any>> = {};
```

### 2. `fossa()` (Root Constructor)

```ts
function fossa<S, E>(def: FSMDefinition<S, E>): FSMInstance<S, E> {
  if (rootFSMInstance) throw new Error("Only one root FSM can be created.");
  const fsm = createFSM(def);
  rootFSMInstance = fsm;
  return fsm;
}
```

### 3. `fossa.child(name, def)` (Named Child Registration)

```ts
fossa.child = function<S, E>(name: string, def: FSMDefinition<S, E>): FSMInstance<S, E> {
  if (!rootFSMInstance) throw new Error("Root FSM must be created first.");
  if (childRegistry[name]) throw new Error(`Child FSM "${name}" already exists.`);
  const child = createFSM(def);
  childRegistry[name] = child;
  return child;
};
```

### 4. `fossa.send(...)` Overload

```ts
fossa.send = function(...args: [any] | [string, any]) {
  if (args.length === 1) {
    const [event] = args;
    if (!rootFSMInstance) throw new Error("No root FSM initialized.");
    rootFSMInstance.send(event);
  } else {
    const [name, event] = args;
    const child = childRegistry[name];
    if (!child) throw new Error(`No child FSM registered as "${name}".`);
    child.send(event);
  }
};
```

---

## ‚úÖ Lifecycle Hook Support

Use the following in `FSMDefinition`:

```ts
type FSMDefinition<S, E> = {
  initial: S;
  transitions: Record<string, Transition<S, E>>;
  onSend?: (event: E, state: S) => void;
  onTransition?: (from: S, to: S, event: E) => void;
  onInit?: (state: S) => void;
  onUnhandled?: (event: unknown, state: S) => void;
};
```

Integrate into `createFSM(...)`.

---

## üì¶ Usage Example

```ts
const root = fossa({
  initial: { state: 'main_menu' },
  transitions: {
    main_menu: (s, e) => e.type === 'start_game' ? { state: 'in_game' } : s
  }
});

const game = fossa.child('game', {
  initial: { state: 'awaiting_player_action' },
  transitions: {
    awaiting_player_action: (s, e) => ({ state: 'resolving_event' })
  }
});

fossa.send({ type: 'start_game' });           // root FSM
fossa.send('game', { type: 'clicked_card' }); // child FSM
```

---

## üß† Bonus Ideas

* `fossa.getChild(name)` ‚Äî get direct access to a child FSM
* `fossa.children` ‚Äî expose child registry for introspection/devtools
* `fossa.reset()` ‚Äî clear registry and root for hot reload/dev