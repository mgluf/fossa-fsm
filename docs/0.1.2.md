## üìù `fossa-fsm@0.1.2`: Builder-First FSM Tree + Lifecycle Hooks + Structured Root

### üöÄ What‚Äôs New in `0.1.2`

* üí° **Builder-first API** ‚Äî FSM tree setup is now explicit and ordered
* üå≥ **Required root FSM** ‚Äî You must define a single top-level FSM
* üß© **Named child FSMs** ‚Äî Register FSMs with unique names under the root
* üìÆ **Scoped event routing** ‚Äî Send to root or child by name
* üîÑ **Lifecycle hooks** ‚Äî FSMs now support `onSend`, `onTransition`, etc.
* üßº **Resettable FSM graph** ‚Äî Clear root and children with `.reset()`

---

## ‚úÖ New Builder API (Default Usage)

```ts
const app = fossa()
  .root({
    initial: { state: 'booting' },
    transitions: {
      booting: (s, e) => ({ state: 'main_menu' })
    }
  })
  .child('game', {
    initial: { state: 'awaiting_player_action' },
    transitions: {
      awaiting_player_action: (s, e) => ({ state: 'resolving_event' })
    }
  })
  .child('settings', {
    initial: { view: 'collapsed' },
    transitions: {
      collapsed: (s, e) => e.type === 'open' ? { view: 'expanded' } : s
    }
  })
  .build(); // returns the root FSM instance
```

---

## ‚ú≥Ô∏è Event Routing

```ts
app.send({ type: 'start_game' });                  // ‚Üí root FSM
app.send('game', { type: 'clicked_card', card });  // ‚Üí child FSM
```

---

## üîê Internal Model

```ts
let rootFSMInstance: FSMInstance<any, any> | null = null;
const childRegistry: Record<string, FSMInstance<any, any>> = {};
```

---

## ‚úÖ Lifecycle Hook Support

FSMs can define lifecycle hooks inside their definitions:

```ts
type FSMDefinition<S, E> = {
  initial: S;
  transitions: Record<string, Transition<S, E>>;
  onInit?: (state: S) => void;
  onSend?: (event: E, state: S) => void;
  onTransition?: (from: S, to: S, event: E) => void;
  onUnhandled?: (event: unknown, state: S) => void;
};
```

These are automatically invoked by the runtime FSM engine during transitions and dispatches.

---

## üì¶ Example with Hooks

```ts
.child('settings', {
  initial: { view: 'collapsed' },
  transitions: {
    collapsed: (s, e) => e.type === 'open' ? { view: 'expanded' } : s
  },
  onInit: (state) => console.log('Settings FSM initialized with', state),
  onSend: (event, state) => console.log('Event in settings:', event)
})
```

---

## üõ† Maintenance API

* All maintenance APIs can accept a string to invoke on a named child.
* If no string is provided it's invoked on the entire tree from Root down.


## Informational:
```ts
fossa.fetch();
fossa.fetch('child');
fossa.children;
```
## Lifecycle
```ts
fossa.reset();                     // clears and resets to initial state
fossa.delete();                   // deletes entire child or root tree instance
fossa.swap(newRoot);             // delete current root and swap in it's place a new root
fossa.swap('child', newChild);  // delete current root and swap in it's place a new root
fossa.spawn('name', {})        // registers a new child fsm on the fly NOT a root
```

---

## üß† Design Philosophy Recap

* **One root to rule them all** ‚Äî all FSMs must descend from a single, structured entry point
* **Explicit architecture over dynamic chaos** ‚Äî FSMs are owned, tracked, and observable
* **Modular but rooted** ‚Äî FSMs don‚Äôt implicitly bubble, but they live in a shared tree
* **Great for any interactive app**, not just games ‚Äî menus, editors, routers, and UIs all benefit from rooted orchestration

---

## Future Ideas

* `fossa.devtools()` ‚Äî inspect active state of the FSM tree
* `fossa.forward(from, to, eventType)` ‚Äî explicit event wiring between FSMs
* `fossa.guard(...)` ‚Äî global precondition hooks
* `fossa.context(...)` ‚Äî optional global read-only context shared to FSMs

