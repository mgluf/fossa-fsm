## 📝 `fossa-fsm@0.1.2`: Builder-First FSM Tree + Lifecycle Hooks + Structured Root

### 🚀 What’s New in `0.1.2`

* 💡 **Builder-first API** — FSM tree setup is now explicit and ordered
* 🌳 **Required root FSM** — You must define a single top-level FSM
* 🧩 **Named child FSMs** — Register FSMs with unique names under the root
* 📮 **Scoped event routing** — Send to root or child by name
* 🔄 **Lifecycle hooks** — FSMs now support `onSend`, `onTransition`, etc.
* 🔄 **Pure logic helpers** — `fossa.update()` and `fossa.match()` for utility use
* 🧼 **Resettable FSM graph** — Clear root and children with `.reset()`

---

## ✅ Builder API (Default Usage)

```ts
const app = fossa()
  .root({
    initial: { state: 'booting' },
    transitions: {
      booting: (s, e) => ({ state: 'main_menu' })
    }
  })
  .child('game', {
    initial: { state: 'awaiting_player_action' },
    transitions: {
      awaiting_player_action: (s, e) => ({ state: 'resolving_event' })
    }
  })
  .child('settings', {
    initial: { view: 'collapsed' },
    transitions: {
      collapsed: (s, e) => e.type === 'open' ? { view: 'expanded' } : s
    }
  })
  .build();
```

---

## ✳️ Event Routing

```ts
app.send({ type: 'start_game' });                  // → root FSM
app.send('game', { type: 'clicked_card', card });  // → child FSM
```

---

## 🔧 New: Pure Transition Utilities

### 🧠 `fossa.update(transitions)`

A stateless helper to evaluate transitions without an FSM instance:

```ts
const update = fossa.update(transitions);
const next = update('awaiting_player_action', { type: 'clicked_card' });
// → { state: 'resolving_event' }
```

Useful for:

* UI previews
* Unit tests
* Replay logs
* SSR-safe prediction

---

### 🧠 `fossa.match(event)`

Pattern-match utility for handling union-type events cleanly:

```ts
fossa.match(event)
  .case('clicked_card', ({ card }) => doSomething(card))
  .case('toggled_fists', ({ enabled }) => toggle(enabled))
  .default(() => fallback());
```

Cleaner than `switch`, fully type-safe.

---

## ✅ Lifecycle Hook Support

FSMs can define:

```ts
{
  onInit(state),
  onSend(event, state),
  onTransition(from, to, event),
  onUnhandled(event, state)
}
```

All hooks are automatically called during runtime transitions.

---

## 🛠 Maintenance API

> All maintenance APIs can accept a string to invoke on a named child.
> If no string is provided, they're invoked on the entire FSM tree.

### Informational

```ts
fossa.fetch();           // root + children
fossa.fetch('game');     // just 'game'
fossa.children;          // map of all child FSMs
```

### Lifecycle

```ts
fossa.reset();                       // reset everything
fossa.reset('settings');            // reset one child

fossa.delete();                     // delete root + all children
fossa.delete('game');              // delete a single FSM

fossa.swap(newRootDef);            // replace root FSM
fossa.swap('game', newDef);        // replace a child FSM

fossa.spawn('overlay', def);       // add a child FSM dynamically
```

---

## 🧠 Design Philosophy

* **Rooted FSM Tree** — every FSM lives within a unified, queryable hierarchy
* **Explicit transitions** — no magic, no implicit bubbling
* **Lifecycle-aware** — track and respond to FSM-level events cleanly
* **Structured, testable logic** — predictable state change with pure helpers
* **Composable** — nest FSMs, isolate concerns, manage scope

---

## Future Ideas

* `fossa.devtools()` — live FSM tree inspector
* `fossa.forward(from, to, eventType)` — event redirection between FSMs
* `fossa.guard(fn)` — global or per-FSM transition gating
* `fossa.context(...)` — read-only global context injection

---

Let me know if you'd like this turned into a Markdown `CHANGELOG.md`, `README` section, or even release notes format for a GitHub release tag. You're in great shape.
