## ðŸ“ `fossa-fsm@0.1.2`: Builder-First FSM Tree + Lifecycle Hooks + Structured Root

### ðŸš€ Whatâ€™s New in `0.1.2`

* ðŸ’¡ **Builder-first API** â€” FSM tree setup is now explicit and ordered
* ðŸŒ³ **Required root FSM** â€” You must define a single top-level FSM
* ðŸ§© **Named child FSMs** â€” Register FSMs with unique names under the root
* ðŸ“® **Scoped event routing** â€” Send to root or child by name
* ðŸ”„ **Lifecycle hooks** â€” FSMs now support `onSend`, `onTransition`, etc.
* ðŸ”„ **Pure logic helpers** â€” `fossa.update()` and `fossa.match()` for utility use
* ðŸ§¼ **Resettable FSM graph** â€” Clear root and children with `.reset()`

---

## âœ… Builder API (Default Usage)

```ts
const app = fossa()
  .root({
    initial: { state: 'booting' },
    transitions: {
      booting: (s, e) => ({ state: 'main_menu' })
    }
  })
  .child('game', {
    initial: { state: 'awaiting_player_action' },
    transitions: {
      awaiting_player_action: (s, e) => ({ state: 'resolving_event' })
    }
  })
  .child('settings', {
    initial: { view: 'collapsed' },
    transitions: {
      collapsed: (s, e) => e.type === 'open' ? { view: 'expanded' } : s
    }
  })
  .build();
```

---

## âœ³ï¸ Event Routing

```ts
app.send({ type: 'start_game' });                  // â†’ root FSM
app.send('game', { type: 'clicked_card', card });  // â†’ child FSM
```

---

## ðŸ”§ New: Pure Transition Utilities

### ðŸ§  `fossa.update(transitions)`

A stateless helper to evaluate transitions without an FSM instance:

```ts
const update = fossa.update(transitions);
const next = update('awaiting_player_action', { type: 'clicked_card' });
// â†’ { state: 'resolving_event' }
```

Useful for:

* UI previews
* Unit tests
* Replay logs
* SSR-safe prediction

---

### ðŸ§  `fossa.match(event)`

Pattern-match utility for handling union-type events cleanly:

```ts
fossa.match(event)
  .case('clicked_card', ({ card }) => doSomething(card))
  .case('toggled_fists', ({ enabled }) => toggle(enabled))
  .default(() => fallback());
```

Cleaner than `switch`, fully type-safe.

---

## âœ… Lifecycle Hook Support

FSMs can define:

```ts
{
  onInit(state),
  onSend(event, state),
  onTransition(from, to, event),
  onUnhandled(event, state)
}
```

All hooks are automatically called during runtime transitions.

---

## ðŸ›  Maintenance API

> All maintenance APIs can accept a string to invoke on a named child.
> If no string is provided, they're invoked on the entire FSM tree.

### Informational

```ts
fossa.fetch();           // root + children
fossa.fetch('game');     // just 'game'
fossa.children;          // map of all child FSMs
```

### Lifecycle

```ts
fossa.reset();                       // reset everything
fossa.reset('settings');            // reset one child

fossa.delete();                     // delete root + all children
fossa.delete('game');              // delete a single FSM

fossa.swap(newRootDef);            // replace root FSM
fossa.swap('game', newDef);        // replace a child FSM

fossa.spawn('overlay', def);       // add a child FSM dynamically
```

---

## ðŸ§  Design Philosophy

* **Rooted FSM Tree** â€” every FSM lives within a unified, queryable hierarchy
* **Explicit transitions** â€” no magic, no implicit bubbling
* **Lifecycle-aware** â€” track and respond to FSM-level events cleanly
* **Structured, testable logic** â€” predictable state change with pure helpers
* **Composable** â€” nest FSMs, isolate concerns, manage scope

---

## Future Ideas

* `fossa.devtools()` â€” live FSM tree inspector
* `fossa.forward(from, to, eventType)` â€” event redirection between FSMs
* `fossa.guard(fn)` â€” global or per-FSM transition gating
* `fossa.context(...)` â€” read-only global context injection

---

Let me know if you'd like this turned into a Markdown `CHANGELOG.md`, `README` section, or even release notes format for a GitHub release tag. You're in great shape.
